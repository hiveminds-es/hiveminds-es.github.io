---
title: "CVE-2020-1337: mis dos centavos"
date: 2020-08-11T20:00:06+01:00
description: "A lo largo de las siguientes líneas se analizará la vulnerabilidad catalogada con el CVE-2020-1048 y se explicará como eludir la protección aplicada con el parche correspondiente para desarrollar una PoC funcional que nos permitirá plantar un binario en un directorio privilegiado (CVE-2020-1337)."
draft: false
hideToc: true
enableToc: false
enableTocContent: false
author: neofito
authorImage: "https://avatars3.githubusercontent.com/u/1921186?s=400&u=6b86038f075e0813761c512d25e0917744741b61&v=4"
socialOptions:
  twitter: "https://twitter.com/neosysforensics"
  github: "https://github.com/neofito"
tags:
- Windows
- EoP
- CVE-2020-1337
categories:
- Windows
- Exploitation
image: 
---

En enero de este mismo año, Peleg Hadar ([@peleghd](https://twitter.com/peleghd)) y Tomer Bar reportaron a Microsoft, sin liberar públicamente los detalles, una vulnerabilidad en el servicio de impresión de Windows que permitiría la elevación de privilegios en los sistemas Windows 7 en adelante. Los correspondientes parches fueron liberados por Microsoft el 12 de mayo y el CVE asignado a la vulnerabilidad fue el ([CVE-2020-1048](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-1048)). 

El mismo día en que fueron liberadas las actualizaciones Alex Ionescu ([@aionescu](https://twitter.com/aionescu)) y Yarden Shafir ([@yarden_shafir](https://twitter.com/yarden_shafir)), los cuales también encontraron dicha vulnerabilidad, publicaron los detalles de su investigación en el artículo [PrintDemon: Print Spooler Privilege Escalation, Persistence & Stealth (CVE-2020-1048 & more)](https://windows-internals.com/printdemon-cve-2020-1048/). Aprovechando este conocimiento y después de algunas pruebas logré encontrar un bypass para el parche de Microsoft utilizando [junction points y symlinks](https://vimeo.com/133002251) (todo el mérito para James Forshaw [@tiraniddo](https://twitter.com/tiraniddo)).

Mi reporte, con fecha 19 de mayo de 2020, fué marcado por Microsoft como duplicado dado que la causa raíz al parecer ya [había sido reportada](https://twitter.com/neosysforensics/status/1293191989635289088) previamente. A la vulnerabilidad se le asignó el [CVE-2020-1337](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-1337), el cual [comparto con otros investigadores](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-1337#Acknowledgements).

En este artículo trataré brevemente de detallar el proceso de explotación de la vulnerabilidad CVE-2020-1048 y el bypass que logré encontrar, incluyendo referencias de interés de obligada lectura.

## CVE-2020-1048

Como ya he comentado, el 12 de mayo de este mismo año Microsoft publicó las actualizaciones de seguridad para el [CVE-2020-1048](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-1048), una vulnerabilidad que permitiría una escalada de privilegios aprovechando el servicio de impresión de Windows:

> An elevation of privilege vulnerability exists when the Windows Print Spooler service improperly allows arbitrary writing to the file system. An attacker who successfully exploited this vulnerability could run arbitrary code with elevated system privileges. An attacker could then install programs; view, change, or delete data; or create new accounts with full user rights.
>
> To exploit this vulnerability, an attacker would have to log on to an affected system and run a specially crafted script or application.
>
> The update addresses the vulnerability by correcting how the Windows Print Spooler Component writes to the file system.

[Yarden Shafir](https://twitter.com/yarden_shafir) y [Alex Ionescu](https://twitter.com/aionescu) publicaron su artículo [PrintDemon: Print Spooler Privilege Escalation, Persistence & Stealth (CVE-2020-1048 & more)](https://windows-internals.com/printdemon-cve-2020-1048/) detallando el origen de la vulnerabilidad y dando algunas pistas para su explotación sin liberar una PoC totalmente funcional, al menos no utilizándola "_as is_".

El proceso de explotación pasa por crear un puerto local de impresora un tanto especial para, posteriormente, crear una impresora virtual asignándole dicho puerto y utilizando un driver genérico. Lo especial del puerto local asignado a la impresora consiste en hacer que apunte a un fichero en un path interesante, por ejemplo `C:\Windows\system32\evil.dll`, dado que durante el proceso de creación del puerto Windows no comprueba si el usuario tiene permisos de escritura en dicha ruta. Si posteriormente desde el contexto de un usuario estándar lanzamos una tarea de impresión utilizando la impresora virtual, la tarea devolverá un error al intentar crear el fichero dado que no tenemos los permisos necesarios para imprimir en dicha ubicación; el servicio de impresión ejecuta el proceso [impersonando](https://docs.microsoft.com/en-us/windows/win32/secauthz/client-impersonation) al usuario que lanzó la tarea, así que hasta aquí todo normal.

Nótese que para apuntar el puerto local a un fichero en `C:\Windows\system32` y posteriormente poder crear la impresora virtual con este puerto y un driver genérico deberemos utilizar PowerShell o hacerlo mediante código, ya que si intentamos utilizar el asistente de creación de impresoras el proceso nos devolverá un error de _Acceso denegado_ al intentar crear el puerto, dado que en este caso si se comprueban correctamente los permisos incluso antes de "crear" realmente el fichero.

![Acceso denegado al crear un puerto local](/posts/CVE-2020-1337_mis_dos_centavos/001.png)

El [artículo](https://windows-internals.com/printdemon-cve-2020-1048/), cuya lectura es absolutamente recomendada, detalla la causa de esta discordancia además de desmenuzar el proceso llevado a cabo por el servicio de impresión de Windows al lanzar una tarea de impresión. Durante este proceso se generan en el directorio `C:\Windows\system32\spool\PRINTERS` los siguientes ficheros:

- `FPnnnnn.SPL` ó `nnnnn.SPL` que básicamente contiene lo que será impreso. 
- `FPnnnnn.SHD` ó `nnnnn.SHD` que contiene los metadatos que definen la tarea de impresión.

No ahondaré en la estructura de el fichero `SHD`, ya que conocerla no resulta imprescindible para entender el procedimiento de explotación llevado a cabo (consultar los [siguientes](https://github.com/ionescu007/PrintDemon) [repositorios](https://github.com/SafeBreach-Labs/Spooler)). Como resumen, cuando se inicia el servicio de impresión de Windows éste comprueba si existe algún fichero shadow (`.SHD`) en el directorio del spooler (normalmente `C:\Windows\system32\spool\PRINTERS`) analizando su contenido y lanzando la impresión del fichero de spool (`.SPL`) asociado y, lo que es más interesante, ejecutando el proceso directamente como `SYSTEM` sin impersonar al usuario que lanzó inicialmente la tarea. Ahora sí, con todas estas piezas, ya podemos montar una prueba de concepto funcional.

Utilizando Visual Studio para abrir el proyecto una vez descargado desde el [repositorio](https://github.com/ionescu007/PrintDemon), el primer paso será modificar en `printserver\pserver.c` el fichero destino utilizado como puerto local de la impresora:

{{< highlight c >}}
    LPWSTR g_PortName = L"c:\\windows\\system32\\evil.dll";
{{< /highlight >}}


Modificaremos también la declaración de las variables `hPrinter` y `hMonitor` asignándoles un valor por defecto igual a `NULL`:

{{< highlight c >}}
    HANDLE hPrinter = NULL;
    HANDLE hMonitor = NULL;
{{< /highlight >}}

Posteriormente agregaremos el fichero de cabecera `strsafe.h` y el siguiente fragmento código, adaptado a partir de una [respuesta](https://stackoverflow.com/questions/14002954/c-programming-how-to-read-the-whole-file-contents-into-a-buffer) en stackoverflow, y que se encargará de copiar el contenido de la DLL maliciosa en una cadena de texto y almacenarla en memoria:

{{< highlight c >}}
    FILE* f;
    wchar_t wDirPath[MAX_PATH];
    DWORD dRet;

    dRet = GetCurrentDirectory(MAX_PATH, wDirPath);
    if (dRet == 0)
    {
        printf("GetCurrentDirectory failed (%d)\n", GetLastError());
        goto CleanupPath;
    }
    wcscat_s(wDirPath, sizeof(wDirPath), L"\\evil.dll");

    _wfopen_s(&f, wDirPath, L"rb");
    fseek(f, 0, SEEK_END);
    long fsize = ftell(f);
    fseek(f, 0, SEEK_SET);

    char* string = malloc(fsize + 1);
    fread(string, 1, fsize, f);
    fclose(f);

    printf("[.] Reading evil.dll: %d bytes\n", fsize);
{{< /highlight >}}

Por último indicar que será [necesario](https://github.com/ionescu007/SpecuCheck/issues/5) tener instalado el [Windows Driver Kit](https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk) para que el proyecto compile correctamente, ya que depende de la librería `ntdllp.lib`.

Ahora, en un sistema Windows 10, sin la actualización correspondiente al [CVE-2020-1048](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-1048) instalada, utilizaremos el binario `printserver.exe` generado colocando en el mismo directorio un fichero de nombre `evil.dll` desde el contexto de un usuario estándar:

![Ejecución del binario printserver modificado](/posts/CVE-2020-1337_mis_dos_centavos/002.png)

La ejecución del binario se quedará esperando nuestra interacción y así lo dejaremos. Si ahora observamos las impresoras disponibles en el sistema advertiremos la existencia de un nuevo dispositivo, PrintDemon, que tiene un documento pausado en la cola:

![Impresora PrintDemon con un documento pausado](/posts/CVE-2020-1337_mis_dos_centavos/003.png)

Necesitaremos reiniciar el servicio de impresión (`spooler`), y dado que estamos utilizando un usuario estándar y no contamos con los permisos suficientes reiniciaremos el sistema para lograrlo. Una vez arrancado accederemos a la cola de la impresora maliciosa y reanudaremos las tareas de impresión:

![Reanudaremos el documento pausado](/posts/CVE-2020-1337_mis_dos_centavos/004.png)

Como resultado habremos conseguido plantar nuestro fichero en un directorio privilegiado: 

![Fichero malicioso en system32](/posts/CVE-2020-1337_mis_dos_centavos/005.png)

Podemos utilizar esta vulnerabilidad junto con la DLL maliciosa desarrollada también por [Yarden Shafir](https://twitter.com/yarden_shafir) y [Alex Ionescu](https://twitter.com/aionescu) en su artículo [Faxing Your Way to SYSTEM — Part Two](https://windows-internals.com/faxing-your-way-to-system/), publicado el 30 de abril, para realizar un ataque de tipo DLL hijacking y escalar privilegios en el sistema. No es el objetivo del presente artículo detallar esa parte del ataque pero puede consultarse el [siguiente hilo en twitter](https://twitter.com/neosysforensics/status/1260850582384005121) para hacerse una idea del proceso completo a seguir.

Unos días despues de la publicación del código de [PrintDemon](https://github.com/ionescu007/PrintDemon), concretamente el 15 de mayo, BC Security ([@BCSecurity1](https://twitter.com/BCSecurity1)), conocido por ser el encargado del mantenimiento del conocido framework [Empire](https://github.com/BC-SECURITY/Empire/), liberó una versión del [exploit](https://github.com/BC-SECURITY/Invoke-PrintDemon) desarrollada en PowerShell. Seguramente sea mi culpa pero lo cierto es que [no he sido capaz de hacerlo funcionar correctamente](https://twitter.com/BCSecurity1/status/1261287868103680002).

Por otra parte, el pasado 5 de agosto Peleg Hadar ([@peleghd](https://twitter.com/peleghd)) y Tomer Bar liberaron los detalles de su investigación acerca del CVE-2020-1048 en sendas charlas en la [Black Hat](https://www.blackhat.com/us-20/briefings/schedule/index.html#a-decade-after-stuxnets-printer-vulnerability-printing-is-still-the-stairway-to-heaven-19685) y DEF CON ([video](https://www.youtube.com/watch?v=RvABLQpiZks), [slides](https://media.defcon.org/DEF%20CON%2028/DEF%20CON%20Safe%20Mode%20presentations/DEF%20CON%20Safe%20Mode%20-%20Peleg%20Hadar%20-%20A%20Decade%20After%20Stuxnet%27s%20Printer%20Vulnerability%20Printing%20is%20still%20the%20Stairway%20to%20Heaven.pdf) y [whitepaper](https://media.defcon.org/DEF%20CON%2028/DEF%20CON%20Safe%20Mode%20presentations/DEF%20CON%20Safe%20Mode%20-%20Peleg%20Hadar%20-%20A%20Decade%20After%20Stuxnet%27s%20Printer%20Vulnerability%20Printing%20is%20still%20the%20Stairway%20to%20Heaven%20wp.pdf)) de este año. El [exploit](https://github.com/SafeBreach-Labs/Spooler/tree/master/SHDWriter), junto con material adicional, puede encontrarse en su [repositorio](https://github.com/SafeBreach-Labs/Spooler) de github.

## Mi bypass para el CVE-2020-1048

Primero eliminaremos la impresora e instalaremos el [parche]((https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-1048)) correspondiente iniciando nuevamente el proceso de creación de la impresora utilizando ahora PowerShell dado que nos permitirá obtener un resultado mas esclarecedor:

![Error al agregar el puerto para la impresora](/posts/CVE-2020-1337_mis_dos_centavos/006.png)

Tal como puede apreciarse en la captura obtenemos un error de acceso denegado al intentar crear el puerto para la impresora. Las modificaciones introducidas por la actualización de seguridad realizan correctamente una comprobación de permisos en el directorio indicado como destino, deteniendo el proceso en este punto; pero si le damos una vuelta, seguro que se nos ocurre algún bypass...

Durante el proceso de creación del puerto local de la impresora Windows comprueba si el usuario tiene permisos de escritura en el directorio indicado así que tendremos que utilizar algún truco para eludir esta comprobación. En este caso utilizaremos los siguientes comandos de PowerShell para probar nuestra idea. 

En primer lugar agregaremos un driver genérico y crearemos un directorio que posteriormente utilizaremos como destino para la impresión:

![Agregamos un driver y creamos un directorio destino](/posts/CVE-2020-1337_mis_dos_centavos/007.png)

Seguidamente crearemos un puerto local apuntando a un fichero en ese directorio y confirmaremos que se haya creado correctamente:

![Agregamos un puerto para la impresora](/posts/CVE-2020-1337_mis_dos_centavos/008.png)

El proceso se completará correctamente dado que nuestro usuario estándar tiene control total tanto sobre el directorio como sobre su contenido. Por último agregaremos la impresora virtual utilizando el driver genérico y el puerto local recién creado:

![Creación de la impresora virtual](/posts/CVE-2020-1337_mis_dos_centavos/009.png)

En este momento pondremos la impresora virtual en pausa:

![Pausando la impresora virtual](/posts/CVE-2020-1337_mis_dos_centavos/010.png)

Ahora mandaremos a imprimir un documento de prueba de forma que se quedará pausado en la cola de la impresora virtual:

![Documento pausado en la cola de la impresora virtual](/posts/CVE-2020-1337_mis_dos_centavos/011.png)

Tal y como hicimos anteriormente, ahora será necesario reiniciar el servicio de impresión, y dado que estamos utilizando un usuario estándar y no contamos con los permisos suficientes nuevamente reiniciaremos el sistema para lograrlo.

Hasta aquí todo normal pero ahora, ¿qué podemos hacer para conseguir escribir en un directorio privilegiado con la configuración que hemos desplegado hasta el momento? La respuesta viene de la mano de [James Forshaw](https://twitter.com/tiraniddo) y su suite de herramientas [symboliclink-testing-tools](https://github.com/googleprojectzero/symboliclink-testing-tools).

Sin ahondar demasiado en los detalles (recomiendo consultar la siguiente [presentación](https://vimeo.com/133002251)) lo que haremos será generar un junction point para el directorio donde apunta nuestro puerto local, `C:\Users\me\test`, para posteriormente mediante otro tipo de enlace simbólico apuntar el fichero dentro de nuestro directorio, `C:\Users\me\test\foobar`, a `C:\windows\system32\evil.dll`:

![Preparando el entorno utilizando symlinks](/posts/CVE-2020-1337_mis_dos_centavos/012.png)

A continuación accederemos a la cola de la impresora maliciosa y reanudaremos la impresión, comprobando posteriormente que se ha creado el fichero, `C:\windows\system32\evil.dll`, aunque con un contenido inservible:

![Confirmación de la creación del fichero](/posts/CVE-2020-1337_mis_dos_centavos/013.png)

Una vez confirmado el bypass y para demostrar el proceso de explotación he desarrollado una [PoC en C#](https://github.com/neofito/CVE-2020-1337) utilizando el paquete [NtApiDotNet](https://www.nuget.org/packages/NtApiDotNet/) publicado por [James Forshaw](https://twitter.com/tiraniddo) para el uso mediante programación de enlaces simbólicos y los paquetes [IlMerge 3.0.40](https://www.nuget.org/packages/ilmerge/3.0.40) y [MSBuild.ILMerge.Task](https://www.nuget.org/packages/MSBuild.ILMerge.Task/) para obtener un binario autocontenido. Después de [molestar un poco](https://twitter.com/neosysforensics/status/1262660686800437251) y tras alguna que otra prueba puedo decir que el código es funcional.

El binario, si se indica como primer parámetro el primer paso en la secuencia de explotación, recibe como segundo parámetro la ruta donde se encuentra el fichero malicioso que será plantado en `C:\Windows\system32`; finalizada su ejecución nos indica que debemos reiniciar el sistema:

![BinaryPlanting.exe paso 1](/posts/CVE-2020-1337_mis_dos_centavos/014.png)

Una vez reiniciado el sistema ejecutaremos el segundo paso, indicando en este caso como segundo parámetro el nombre con el que el contenido del fichero indicado en el primer paso será creado en el directorio `C:\Windows\system32`:

![BinaryPlanting.exe paso 2](/posts/CVE-2020-1337_mis_dos_centavos/015.png)

Como resultado habremos conseguido copiar una DLL maliciosa en el directorio `C:\Windows\system32` lo que nos permitiría llevar a cabo un ataque de DLL hijacking para elevar privilegios en un sistema vulnerable.

## Enlaces de interés

- [CVE-2020-1048 | Windows Print Spooler Elevation of Privilege Vulnerability](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-1048)
- [PrintDemon: Print Spooler Privilege Escalation, Persistence & Stealth (CVE-2020-1048 & more)](https://windows-internals.com/printdemon-cve-2020-1048/)
- [PrintDemon (CVE-2020-1048)](https://github.com/ionescu007/PrintDemon)
- [Invoke-PrintDemon](https://github.com/BC-SECURITY/Invoke-PrintDemon)
- [DEF CON Safe Mode - Peleg Hadar and Tomer Bar - After Stuxnet Printing still the Stairway to Heaven](https://www.youtube.com/watch?v=RvABLQpiZks)
- [Print Spooler Research Tools](https://github.com/SafeBreach-Labs/Spooler)
- [Windows Print Spooler Patch Bypass Re-Enables Persistent Backdoor](https://www.zerodayinitiative.com/blog/2020/8/11/windows-print-spooler-patch-bypass-re-enables-persistent-backdoor)
- [CVE-2020-1337 Windows Privilege Escalation](https://github.com/math1as/CVE-2020-1337-exploit)
- [CVE-2020-1337 – PrintDemon is dead, long live PrintDemon!](https://voidsec.com/cve-2020-1337-printdemon-is-dead-long-live-printdemon/)
- [cve-2020-1337-poc](https://github.com/sailay1996/cve-2020-1337-poc) 
- [CVE-2020-1337 - Binary Planting (CVE-2020-1048 bypass)](https://github.com/neofito/CVE-2020-1337)
